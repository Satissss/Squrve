# [Question]: Retrieve all non-empty, non-commented lines from `README.md` files in GitHub repositories, excluding lines that are comments (either starting with `#` for Markdown or `//` for code comments). For each line, calculate how often each unique line appears across all repositories and return a comma-separated list of the programming languages used in each repository containing that line, sorted alphabetically, with the results ordered by the frequency of occurrence in descending order.
# [Schema links]: ['SAMPLE_CONTENTS.id', 'SAMPLE_CONTENTS.content', 'SAMPLE_FILES.id', 'SAMPLE_FILES.repo_name', 'SAMPLE_FILES.path', 'LANGUAGES.repo_name', 'LANGUAGES.language']
# [Analysis]: # Output: Letâ€™s think step by step.
1. Identify the relevant tables: `SAMPLE_CONTENTS` (id, content), `SAMPLE_FILES` (id, repo_name, path), and `LANGUAGES` (repo_name, language).
2. Filter `SAMPLE_FILES` to only include rows where the path ends with 'readme.md' (case-insensitive).
3. Extract programming languages from the `LANGUAGES` table by flattening the `language` array to get individual language names.
4. Join `SAMPLE_FILES` with the flattened languages on `repo_name` to associate each file with its repository's languages.
5. Join the result with `SAMPLE_CONTENTS` on `id` to get the content of each README.md file.
6. Split the content into individual lines using `SPLIT` on newline characters.
7. Flatten the lines array to process each line separately.
8. Filter out empty lines and lines that are comments (starting with '#' or '//' after trimming).
9. For each non-empty, non-comment line, count its frequency across all repositories and aggregate the associated programming languages.
10. Sort the aggregated languages alphabetically for each line.
11. Format the output by cleaning the line text (removing quotes), converting the sorted languages array to a comma-separated string.
12. Order the final results by frequency in descending order.
# [Sql]: WITH content_extracted AS (     SELECT          "D"."id" AS "id",         "repo_name",         "path",         SPLIT("content", '\n') AS "lines",         "language_name"     FROM          (             SELECT                  "id",                 "content"             FROM                  "GITHUB_REPOS"."GITHUB_REPOS"."SAMPLE_CONTENTS"         ) AS "D"     INNER JOIN          (             SELECT                  "id",                 "C"."repo_name" AS "repo_name",                 "path",                 "language_name"             FROM                  (                     SELECT                          "id",                         "repo_name",                         "path"                     FROM                          "GITHUB_REPOS"."GITHUB_REPOS"."SAMPLE_FILES"                     WHERE                          LOWER("path") LIKE '%readme.md'                 ) AS "C"             INNER JOIN                  (                     SELECT                          "repo_name",                         "language_struct".value:"name" AS "language_name"                     FROM                          (                             SELECT                                  "repo_name",                                  "language"                             FROM                                  "GITHUB_REPOS"."GITHUB_REPOS"."LANGUAGES"                         )                     CROSS JOIN                          LATERAL FLATTEN(INPUT => "language") AS "language_struct"                 ) AS "F"             ON                  "C"."repo_name" = "F"."repo_name"         ) AS "E"     ON          "E"."id" = "D"."id" ), non_empty_lines AS (     SELECT          "line".value AS "line_",         "language_name"     FROM          content_extracted,         LATERAL FLATTEN(INPUT => "lines") AS "line"     WHERE          TRIM("line".value) != ''         AND NOT STARTSWITH(TRIM("line".value), '#')         AND NOT STARTSWITH(TRIM("line".value), '//') ), aggregated_languages AS (     SELECT          "line_",         COUNT(*) AS "frequency",         ARRAY_AGG("language_name") AS "languages"     FROM          non_empty_lines     GROUP BY          "line_" )  SELECT      REGEXP_REPLACE("line_", '^"|"$', '') AS "line",     "frequency",     ARRAY_TO_STRING(ARRAY_SORT("languages"), ', ') AS "languages_sorted" FROM      aggregated_languages ORDER BY      "frequency" DESC;