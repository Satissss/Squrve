# [Question]: Using double-entry bookkeeping principles by treating transaction inputs as debits (negative values) and outputs as credits (positive values) for all Bitcoin Cash transactions between 2014-03-01 and 2014-04-01, how can we calculate the maximum and minimum final balances grouped by address type from these transactions?
# [Schema links]: ['TRANSACTIONS.inputs', 'TRANSACTIONS.block_timestamp', 'TRANSACTIONS.outputs']
# [Analysis]: # Output: Letâ€™s think step by step.
1. Identify the relevant table and columns: `TRANSACTIONS` with `inputs`, `outputs`, and `block_timestamp` for Bitcoin Cash transactions.
2. Filter transactions to the date range 2014-03-01 to 2014-04-01 by converting `block_timestamp` to a timestamp.
3. Use `LATERAL FLATTEN` on the `inputs` array to break down each input into individual records, treating each as a debit (negative value).
4. For each input, extract the address (using `ARRAY_TO_STRING` to handle multiple addresses), type, and value (negated for debit).
5. Similarly, use `LATERAL FLATTEN` on the `outputs` array to break down each output into individual records, treating each as a credit (positive value).
6. For each output, extract the address, type, and value (positive for credit).
7. Combine both debits (inputs) and credits (outputs) using `UNION ALL` to create a double-entry bookkeeping dataset.
8. Group the combined data by address and type to calculate the final balance for each address using `SUM(value)`.
9. Then group by type to find the maximum and minimum balances across all addresses for each type.
10. Clean the type field by removing any double quotes using `REPLACE`.
11. Order the final result by type for organized output.
# [Sql]: WITH double_entry_book AS (     -- debits     SELECT         ARRAY_TO_STRING("inputs".value:addresses, ',') AS "address",  -- Use the correct JSON path notation         "inputs".value:type AS "type",         - "inputs".value:value AS "value"     FROM CRYPTO.CRYPTO_BITCOIN_CASH.TRANSACTIONS,          LATERAL FLATTEN(INPUT => "inputs") AS "inputs"     WHERE TO_TIMESTAMP("block_timestamp" / 1000000) >= '2014-03-01'        AND TO_TIMESTAMP("block_timestamp" / 1000000) < '2014-04-01'      UNION ALL       -- credits     SELECT         ARRAY_TO_STRING("outputs".value:addresses, ',') AS "address",  -- Use the correct JSON path notation         "outputs".value:type AS "type",         "outputs".value:value AS "value"     FROM CRYPTO.CRYPTO_BITCOIN_CASH.TRANSACTIONS,           LATERAL FLATTEN(INPUT => "outputs") AS "outputs"     WHERE TO_TIMESTAMP("block_timestamp" / 1000000) >= '2014-03-01'        AND TO_TIMESTAMP("block_timestamp" / 1000000) < '2014-04-01' ), address_balances AS (     SELECT          "address",         "type",         SUM("value") AS "balance"     FROM double_entry_book     GROUP BY "address", "type" ), max_min_balances AS (     SELECT         "type",         MAX("balance") AS max_balance,         MIN("balance") AS min_balance     FROM address_balances     GROUP BY "type" ) SELECT     REPLACE("type", '"', '') AS "type",  -- Replace double quotes with nothing     max_balance,     min_balance FROM max_min_balances ORDER BY "type";