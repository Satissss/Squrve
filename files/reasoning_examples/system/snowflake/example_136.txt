# [Question]: Can you list the email addresses of the top 10 users who registered in 2019 and made purchases in 2019, ranking them by their highest average order value, where average order value is calculated by multiplying the number of items in each order by the sale price, summing this total across all orders for each user, and then dividing by the total number of orders?
# [Schema links]: [users.id, users.email, users.gender, users.country, users.traffic_source, orders.user_id, orders.order_id, orders.created_at, orders.num_of_item, order_items.user_id, order_items.order_id, order_items.product_id, order_items.sale_price, order_items.status]
# [Analysis]: Letâ€™s think step by step.
1. Filter users registered in 2019 by converting their registration timestamp and selecting those with `created_at` between 2019-01-01 and 2019-12-31.
2. Extract orders placed in 2019 by converting their `created_at` timestamp and filtering between the same date range.
3. Extract order items with `created_at` in 2019 to include product and sale price details.
4. Join order items with orders to combine per-order data (num_of_item, order_date) and item-level data (sale_price), calculating `total_sale` as `num_of_item * sale_price`.
5. Aggregate per user to compute total lifetime value (sum of `total_sale`), number of orders, and other metrics like `lifespan_months`.
6. Calculate `avg_order_value` by dividing total lifetime value (`ltv`) by the number of orders (`no_of_order`).
7. Join filtered user data with aggregated order metrics to include user details and calculated `avg_order_value`.
8. Sort users by `avg_order_value` in descending order and limit the result to the top 10 emails.
# [Sql]: WITH   main AS (     SELECT       "id" AS "user_id",       "email",       "gender",       "country",       "traffic_source"     FROM       "THELOOK_ECOMMERCE"."THELOOK_ECOMMERCE"."USERS"     WHERE       TO_TIMESTAMP("created_at" / 1000000.0) BETWEEN TO_TIMESTAMP('2019-01-01') AND TO_TIMESTAMP('2019-12-31')   ),    daate AS (     SELECT       "user_id",       "order_id",       CAST(TO_TIMESTAMP("created_at" / 1000000.0) AS DATE) AS "order_date",       "num_of_item"     FROM       "THELOOK_ECOMMERCE"."THELOOK_ECOMMERCE"."ORDERS"     WHERE       TO_TIMESTAMP("created_at" / 1000000.0) BETWEEN TO_TIMESTAMP('2019-01-01') AND TO_TIMESTAMP('2019-12-31')   ),    orders AS (     SELECT       "user_id",       "order_id",       "product_id",       "sale_price",       "status"     FROM       "THELOOK_ECOMMERCE"."THELOOK_ECOMMERCE"."ORDER_ITEMS"     WHERE       TO_TIMESTAMP("created_at" / 1000000.0) BETWEEN TO_TIMESTAMP('2019-01-01') AND TO_TIMESTAMP('2019-12-31')   ),    nest AS (     SELECT       o."user_id",       o."order_id",       o."product_id",       d."order_date",       d."num_of_item",       ROUND(o."sale_price", 2) AS "sale_price",       ROUND(d."num_of_item" * o."sale_price", 2) AS "total_sale"     FROM       orders o     INNER JOIN       daate d     ON       o."order_id" = d."order_id"     ORDER BY       o."user_id"   ),    type AS (     SELECT       "user_id",       MIN(nest."order_date") AS "cohort_date",       MAX(nest."order_date") AS "latest_shopping_date",       DATEDIFF(MONTH, MIN(nest."order_date"), MAX(nest."order_date")) AS "lifespan_months",       ROUND(SUM("total_sale"), 2) AS "ltv",       COUNT("order_id") AS "no_of_order"     FROM       nest     GROUP BY       "user_id"   ),    kite AS (     SELECT       m."user_id",       m."email",       m."gender",       m."country",       m."traffic_source",       EXTRACT(YEAR FROM n."cohort_date") AS "cohort_year",       n."latest_shopping_date",       n."lifespan_months",       n."ltv",       n."no_of_order",       ROUND(n."ltv" / n."no_of_order", 2) AS "avg_order_value"     FROM       main m     INNER JOIN       type n     ON       m."user_id" = n."user_id"   )  SELECT   "email" FROM   kite ORDER BY   "avg_order_value" DESC LIMIT 10;