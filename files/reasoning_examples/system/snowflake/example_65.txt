# [Question]: Considering only CT images from the 'nlst' collection, what are the average series sizes in MiB for the top 3 patients with the highest slice interval difference tolerance (calculated as the difference between the maximum and minimum unique slice intervals within their series) and the top 3 patients with the highest maximum exposure difference (calculated as the difference between the maximum and minimum unique exposure values within their series), where the series size is determined by summing the instance sizes of all images in a series and converting it to MiB?
# [Schema links]: ["IDC_V17.DICOM_ALL.SeriesInstanceUID", "IDC_V17.DICOM_ALL.StudyInstanceUID", "IDC_V17.DICOM_ALL.PatientID", "IDC_V17.DICOM_ALL.Exposure", "IDC_V17.DICOM_ALL.ImagePositionPatient", "IDC_V17.DICOM_ALL.instance_size", "IDC_V17.DICOM_ALL.collection_id", "IDC_V17.DICOM_ALL.Modality"]
# [Analysis]: Let’s think step by step.  
1. Filter the `IDC_V17.DICOM_ALL` table for records with `collection_id` 'nlst' and `Modality` 'CT' to focus on relevant CT images.  
2. Extract z-axis coordinates from `ImagePositionPatient` arrays using `LATERAL FLATTEN`, then compute slice intervals between consecutive slices using `LEAD()`.  
3. For each series, aggregate distinct slice intervals and distinct exposure values, sum instance sizes to calculate series size in MiB.  
4. For each series, compute `sliceIntervalDifferenceTolerance` (max - min of distinct slice intervals) and `maxExposureDifference` (max - min of distinct exposures).  
5. Rank all series by `sliceIntervalDifferenceTolerance`, select the top 3 series, and retain their `PatientID` and series size.  
6. Similarly, rank all series by `maxExposureDifference`, select the top 3 series, and retain their `PatientID` and series size.  
7. Calculate the average series size (in MiB) for the top 3 series in each category using `AVG()` and combine results with `UNION ALL`.
# [Sql]: WITH   nonLocalizerRawData AS (     SELECT       "SeriesInstanceUID",       "StudyInstanceUID",       "PatientID",       TRY_CAST("Exposure"::STRING AS FLOAT) AS "Exposure",  -- 直接从 bid 获取 Exposure       TRY_CAST(axes.VALUE::STRING AS FLOAT) AS "zImagePosition",       LEAD(TRY_CAST(axes.VALUE::STRING AS FLOAT)) OVER (         PARTITION BY "SeriesInstanceUID"          ORDER BY TRY_CAST(axes.VALUE::STRING AS FLOAT)       ) - TRY_CAST(axes.VALUE::STRING AS FLOAT) AS "slice_interval",       "instance_size" AS "instanceSize"     FROM       "IDC"."IDC_V17"."DICOM_ALL" AS "bid",       LATERAL FLATTEN(input => "bid"."ImagePositionPatient") AS axes  -- 使用 LATERAL FLATTEN 展开数组     WHERE       "collection_id" = 'nlst'        AND "Modality" = 'CT'    ),   geometryChecks AS (     SELECT       "SeriesInstanceUID",       "StudyInstanceUID",       "PatientID",       ARRAY_AGG(DISTINCT "slice_interval") AS "sliceIntervalDifferences",       ARRAY_AGG(DISTINCT "Exposure") AS "distinctExposures",       SUM("instanceSize") / 1024 / 1024 AS "seriesSizeInMB"     FROM       nonLocalizerRawData     GROUP BY       "SeriesInstanceUID",        "StudyInstanceUID",       "PatientID"   ),   patientMetrics AS (     SELECT       "PatientID",       MAX(TRY_CAST(sid.VALUE::STRING AS FLOAT)) AS "maxSliceIntervalDifference",       MIN(TRY_CAST(sid.VALUE::STRING AS FLOAT)) AS "minSliceIntervalDifference",       MAX(TRY_CAST(sid.VALUE::STRING AS FLOAT)) - MIN(TRY_CAST(sid.VALUE::STRING AS FLOAT)) AS "sliceIntervalDifferenceTolerance",       MAX(TRY_CAST(de.VALUE::STRING AS FLOAT)) AS "maxExposure",       MIN(TRY_CAST(de.VALUE::STRING AS FLOAT)) AS "minExposure",       MAX(TRY_CAST(de.VALUE::STRING AS FLOAT)) - MIN(TRY_CAST(de.VALUE::STRING AS FLOAT)) AS "maxExposureDifference",       "seriesSizeInMB"     FROM       geometryChecks,       LATERAL FLATTEN(input => "sliceIntervalDifferences") AS sid,  -- 展开 sliceIntervalDifferences       LATERAL FLATTEN(input => "distinctExposures") AS de  -- 展开 distinctExposures     WHERE       sid.VALUE IS NOT NULL       AND de.VALUE IS NOT NULL     GROUP BY       "PatientID",       "seriesSizeInMB"   ),   top3BySliceInterval AS (     SELECT       "PatientID",       "seriesSizeInMB"     FROM       patientMetrics     ORDER BY       "sliceIntervalDifferenceTolerance" DESC     LIMIT 3   ),   top3ByMaxExposure AS (     SELECT       "PatientID",       "seriesSizeInMB"     FROM       patientMetrics     ORDER BY       "maxExposureDifference" DESC     LIMIT 3   ) SELECT   'Top 3 by Slice Interval' AS "MetricGroup",   AVG("seriesSizeInMB") AS "AverageSeriesSizeInMB" FROM   top3BySliceInterval UNION ALL SELECT   'Top 3 by Max Exposure' AS "MetricGroup",   AVG("seriesSizeInMB") AS "AverageSeriesSizeInMB" FROM   top3ByMaxExposure;