# [Question]: Using double-entry bookkeeping principles by treating transaction inputs as debits (negative values) and outputs as credits (positive values) for all Bitcoin Cash transactions between 2014-03-01 and 2014-04-01, how can we calculate the maximum and minimum final balances grouped by address type from these transactions?
# [Schema links]: ["CRYPTO_BITCOIN_CASH.TRANSACTIONS.block_timestamp", "CRYPTO_BITCOIN_CASH.TRANSACTIONS.inputs.value:addresses", "CRYPTO_BITCOIN_CASH.TRANSACTIONS.inputs.value:type", "CRYPTO_BITCOIN_CASH.TRANSACTIONS.inputs.value:value", "CRYPTO_BITCOIN_CASH.TRANSACTIONS.outputs.value:addresses", "CRYPTO_BITCOIN_CASH.TRANSACTIONS.outputs.value:type", "CRYPTO_BITCOIN_CASH.TRANSACTIONS.outputs.value:value"]
# [Analysis]: Letâ€™s think step by step.
1. Identify the relevant columns: `block_timestamp`, `inputs.value:addresses`, `inputs.value:type`, `inputs.value:value`, `outputs.value:addresses`, `outputs.value:type`, `outputs.value:value` from the `CRYPTO_BITCOIN_CASH.TRANSACTIONS` table.
2. Process inputs as debits by flattening the `inputs` array, negating their `value`, and extracting addresses and types using JSON path notation.
3. Process outputs as credits by flattening the `outputs` array, retaining their `value`, and extracting addresses and types similarly.
4. Combine debits and credits into a single CTE (`double_entry_book`) using `UNION ALL`, ensuring date filtering for transactions between 2014-03-01 and 2014-04-01.
5. Calculate the final balance for each address and type by summing the combined values in `double_entry_book` grouped by `address` and `type`.
6. Aggregate the maximum and minimum balances for each address type by grouping the `address_balances` results by `type`.
7. Clean the `type` column by removing quotes and format the final output with `type`, `max_balance`, and `min_balance`, ordered by `type`.
# [Sql]: WITH double_entry_book AS (     -- debits     SELECT         ARRAY_TO_STRING("inputs".value:addresses, ',') AS "address",  -- Use the correct JSON path notation         "inputs".value:type AS "type",         - "inputs".value:value AS "value"     FROM CRYPTO.CRYPTO_BITCOIN_CASH.TRANSACTIONS,          LATERAL FLATTEN(INPUT => "inputs") AS "inputs"     WHERE TO_TIMESTAMP("block_timestamp" / 1000000) >= '2014-03-01'        AND TO_TIMESTAMP("block_timestamp" / 1000000) < '2014-04-01'      UNION ALL       -- credits     SELECT         ARRAY_TO_STRING("outputs".value:addresses, ',') AS "address",  -- Use the correct JSON path notation         "outputs".value:type AS "type",         "outputs".value:value AS "value"     FROM CRYPTO.CRYPTO_BITCOIN_CASH.TRANSACTIONS,           LATERAL FLATTEN(INPUT => "outputs") AS "outputs"     WHERE TO_TIMESTAMP("block_timestamp" / 1000000) >= '2014-03-01'        AND TO_TIMESTAMP("block_timestamp" / 1000000) < '2014-04-01' ), address_balances AS (     SELECT          "address",         "type",         SUM("value") AS "balance"     FROM double_entry_book     GROUP BY "address", "type" ), max_min_balances AS (     SELECT         "type",         MAX("balance") AS max_balance,         MIN("balance") AS min_balance     FROM address_balances     GROUP BY "type" ) SELECT     REPLACE("type", '"', '') AS "type",  -- Replace double quotes with nothing     max_balance,     min_balance FROM max_min_balances ORDER BY "type";