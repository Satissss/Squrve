# [Question]: Identify the top five CT scan series by size (in MiB), including their SeriesInstanceUID, series number, patient ID, and series size. These series must be from the CT modality and not part of the 'nlst' collection. Exclude any series where the ImageType is classified as 'LOCALIZER' or where the TransferSyntaxUID is either '1.2.840.10008.1.2.4.70' or '1.2.840.10008.1.2.4.51' (i.e., JPEG compressed). The selected series must have consistent slice intervals, exposure levels, image orientation (with only one unique ImageOrientationPatient value), pixel spacing, image positions (both z-axis and xy positions), and pixel dimensions (rows and columns). Ensure that the number of images matches the number of unique z-axis positions, indicating no duplicate slices. Additionally, the z-axis component of the cross product of the x and y direction cosines from ImageOrientationPatient must have an absolute value between 0.99 and 1.01, ensuring alignment with the expected imaging plane. Finally, order the results by series size in descending order and limit the output to the top five series satisfying these conditions.
# [Schema links]: ['DICOM_ALL.SeriesInstanceUID', 'DICOM_ALL.ImageType', 'DICOM_ALL.TransferSyntaxUID', 'DICOM_ALL.ImageOrientationPatient', 'DICOM_ALL.collection_id', 'DICOM_ALL.Modality', 'DICOM_ALL.StudyInstanceUID', 'DICOM_ALL.PatientID', 'DICOM_ALL.SOPInstanceUID', 'DICOM_ALL.SliceThickness', 'DICOM_ALL.SeriesNumber', 'DICOM_ALL.aws_bucket', 'DICOM_ALL.crdc_series_uuid', 'DICOM_ALL.Exposure', 'DICOM_ALL.ImagePositionPatient', 'DICOM_ALL.PixelSpacing', 'DICOM_ALL.Rows', 'DICOM_ALL.Columns', 'DICOM_ALL.instance_size']
# [Analysis]: # Output: Letâ€™s think step by step.
1. Identify the need to exclude series with ImageType 'LOCALIZER' or specific TransferSyntaxUID values by creating a CTE (localizerAndJpegCompressedSeries) that lists SeriesInstanceUIDs meeting these exclusion criteria.
2. Extract and process ImageOrientationPatient to calculate cross product components: create CTEs (imageOrientation and imageOrientationY) to separate x_vector (first three elements) and y_vector (next three elements) for each series.
3. Create a main data CTE (nonLocalizerRawData) that filters for CT modality, excludes 'nlst' collection and excluded series, and extracts key attributes including z-axis and xy positions from ImagePositionPatient using LATERAL FLATTEN.
4. Calculate the cross product of x_vector and y_vector to determine the imaging plane orientation, storing results in a CTE (crossProduct).
5. Extract individual components (x, y, z) from the cross product object using LATERAL FLATTEN in a CTE (crossProductElements) for subsequent dot product calculation.
6. Compute the dot product of the cross product vector with (0,0,1) to get the z-component magnitude in a CTE (dotProduct), which must be between 0.99 and 1.01 for valid alignment.
7. Aggregate series-level data in a CTE (geometryChecks) to check consistency conditions: unique slice intervals, exposures, image orientation, pixel spacing, positions, pixel dimensions, and match between SOPInstance count and unique z-positions.
8. Include the dot product result in the aggregation to enforce the alignment constraint via HAVING clause.
9. Calculate series size in MiB by summing instance sizes and converting from bytes.
10. Select the required output columns (SeriesInstanceUID, SeriesNumber, PatientID, seriesSizeInMiB) from the geometryChecks CTE.
11. Order the results by seriesSizeInMiB in descending order and limit to the top 5 series.
# [Sql]: WITH   -- Create a common table expression (CTE) named localizerAndJpegCompressedSeries   localizerAndJpegCompressedSeries AS (     SELECT        "SeriesInstanceUID"     FROM        IDC.IDC_V17."DICOM_ALL" AS bid     WHERE        "ImageType" = 'LOCALIZER' OR       "TransferSyntaxUID" IN ('1.2.840.10008.1.2.4.70', '1.2.840.10008.1.2.4.51')   ),      -- Create a common table expression (CTE) for x_vector calculation (first three elements)   imageOrientation AS (     SELECT       "SeriesInstanceUID",       ARRAY_AGG(CAST(part.value AS FLOAT)) AS "x_vector"     FROM        IDC.IDC_V17."DICOM_ALL" AS bid,       LATERAL FLATTEN(input => bid."ImageOrientationPatient") AS part     WHERE       part.index BETWEEN 0 AND 2     GROUP BY "SeriesInstanceUID"   ),      -- Create a common table expression (CTE) for y_vector calculation (next three elements)   imageOrientationY AS (     SELECT       "SeriesInstanceUID",       ARRAY_AGG(CAST(part.value AS FLOAT)) AS "y_vector"     FROM        IDC.IDC_V17."DICOM_ALL" AS bid,       LATERAL FLATTEN(input => bid."ImageOrientationPatient") AS part     WHERE       part.index BETWEEN 3 AND 5     GROUP BY "SeriesInstanceUID"   ),      -- Create a common table expression (CTE) named nonLocalizerRawData   nonLocalizerRawData AS (     SELECT       bid."SeriesInstanceUID",  -- Added table alias bid       bid."StudyInstanceUID",       bid."PatientID",       bid."SOPInstanceUID",       bid."SliceThickness",       bid."ImageType",       bid."TransferSyntaxUID",       bid."SeriesNumber",       bid."aws_bucket",       bid."crdc_series_uuid",       CAST(bid."Exposure" AS FLOAT) AS "Exposure",  -- Use CAST directly       CAST(ipp.value AS FLOAT) AS "zImagePosition", -- Use CAST directly       CONCAT(ipp2.value, '/', ipp3.value) AS "xyImagePosition",       LEAD(CAST(ipp.value AS FLOAT)) OVER (PARTITION BY bid."SeriesInstanceUID" ORDER BY CAST(ipp.value AS FLOAT)) - CAST(ipp.value AS FLOAT) AS "slice_interval",       ARRAY_TO_STRING(bid."ImageOrientationPatient", '/') AS "iop",       bid."PixelSpacing",       bid."Rows" AS "pixelRows",       bid."Columns" AS "pixelColumns",       bid."instance_size" AS "instanceSize"     FROM       IDC.IDC_V17."DICOM_ALL" AS bid     LEFT JOIN LATERAL FLATTEN(input => bid."ImagePositionPatient") AS ipp     LEFT JOIN LATERAL FLATTEN(input => bid."ImagePositionPatient") AS ipp2     LEFT JOIN LATERAL FLATTEN(input => bid."ImagePositionPatient") AS ipp3     WHERE       bid."collection_id" != 'nlst'       AND bid."Modality" = 'CT'       AND ipp.index = 2       AND ipp2.index = 0       AND ipp3.index = 1       AND bid."SeriesInstanceUID" NOT IN (SELECT "SeriesInstanceUID" FROM localizerAndJpegCompressedSeries)   ),      -- Cross product calculation   crossProduct AS (     SELECT       nld."SOPInstanceUID",  -- Added table alias nld       nld."SeriesInstanceUID",  -- Added table alias nld       OBJECT_CONSTRUCT(         'x', ("x_vector"[1] * "y_vector"[2] - "x_vector"[2] * "y_vector"[1]),         'y', ("x_vector"[2] * "y_vector"[0] - "x_vector"[0] * "y_vector"[2]),         'z', ("x_vector"[0] * "y_vector"[1] - "x_vector"[1] * "y_vector"[0])       ) AS "xyCrossProduct"     FROM        nonLocalizerRawData AS nld  -- Added alias for nonLocalizerRawData     JOIN imageOrientation AS io ON nld."SeriesInstanceUID" = io."SeriesInstanceUID"     JOIN imageOrientationY AS ioy ON nld."SeriesInstanceUID" = ioy."SeriesInstanceUID"   ),      -- Cross product elements extraction and row numbering   crossProductElements AS (     SELECT       cp."SOPInstanceUID",         cp."SeriesInstanceUID",         elem.value,       ROW_NUMBER() OVER (PARTITION BY cp."SOPInstanceUID", cp."SeriesInstanceUID" ORDER BY elem.value) AS rn     FROM        crossProduct AS cp       -- Use LATERAL FLATTEN to explode the cross product object into individual 'x', 'y', and 'z'     JOIN LATERAL FLATTEN(input => ARRAY_CONSTRUCT(           cp."xyCrossProduct"['x'],           cp."xyCrossProduct"['y'],           cp."xyCrossProduct"['z']     )) AS elem -- Simplified 'elem.value' reference here   ),      -- Dot product calculation   dotProduct AS (     SELECT       cpe."SOPInstanceUID",         cpe."SeriesInstanceUID",         SUM(         CASE            WHEN cpe.rn = 1 THEN cpe.value * 0  -- x * 0           WHEN cpe.rn = 2 THEN cpe.value * 0  -- y * 0           WHEN cpe.rn = 3 THEN cpe.value * 1  -- z * 1         END       ) AS "xyDotProduct"     FROM        crossProductElements AS cpe     GROUP BY        cpe."SOPInstanceUID",         cpe."SeriesInstanceUID"   ),      -- Geometry checks for series consistency   geometryChecks AS (     SELECT       gc."SeriesInstanceUID",  -- Added table alias gc       gc."SeriesNumber",       gc."aws_bucket",       gc."crdc_series_uuid",       gc."StudyInstanceUID",       gc."PatientID",       ARRAY_AGG(DISTINCT gc."slice_interval") AS "sliceIntervalDifferences",       ARRAY_AGG(DISTINCT gc."Exposure") AS "distinctExposures",       COUNT(DISTINCT gc."iop") AS "iopCount",       COUNT(DISTINCT gc."PixelSpacing") AS "pixelSpacingCount",       COUNT(DISTINCT gc."zImagePosition") AS "positionCount",       COUNT(DISTINCT gc."xyImagePosition") AS "xyPositionCount",       COUNT(DISTINCT gc."SOPInstanceUID") AS "sopInstanceCount",       COUNT(DISTINCT gc."SliceThickness") AS "sliceThicknessCount",       COUNT(DISTINCT gc."Exposure") AS "exposureCount",       COUNT(DISTINCT gc."pixelRows") AS "pixelRowCount",       COUNT(DISTINCT gc."pixelColumns") AS "pixelColumnCount",       dp."xyDotProduct",  -- Added xyDotProduct from dotProduct       SUM(gc."instanceSize") / 1024 / 1024 AS "seriesSizeInMiB"     FROM        nonLocalizerRawData AS gc  -- Added table alias gc     JOIN dotProduct AS dp ON gc."SeriesInstanceUID" = dp."SeriesInstanceUID"      AND gc."SOPInstanceUID" = dp."SOPInstanceUID"     GROUP BY       gc."SeriesInstanceUID",        gc."SeriesNumber",       gc."aws_bucket",       gc."crdc_series_uuid",       gc."StudyInstanceUID",       gc."PatientID",       dp."xyDotProduct"  -- Include xyDotProduct in GROUP BY     HAVING       COUNT(DISTINCT gc."iop") = 1        AND COUNT(DISTINCT gc."PixelSpacing") = 1         AND COUNT(DISTINCT gc."SOPInstanceUID") = COUNT(DISTINCT gc."zImagePosition")        AND COUNT(DISTINCT gc."xyImagePosition") = 1       AND COUNT(DISTINCT gc."pixelRows") = 1        AND COUNT(DISTINCT gc."pixelColumns") = 1        AND ABS(dp."xyDotProduct") BETWEEN 0.99 AND 1.01   )  SELECT   geometryChecks."SeriesInstanceUID",  -- Added table alias   geometryChecks."SeriesNumber",  -- Added table alias   geometryChecks."PatientID",  -- Added table alias   geometryChecks."seriesSizeInMiB" FROM   geometryChecks ORDER BY   geometryChecks."seriesSizeInMiB" DESC LIMIT 5;